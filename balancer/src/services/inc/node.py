import decimal
from typing import Optional, Union, Tuple, Dict

from tronpy.tron import TAddress
from tronpy.exceptions import AddressNotFound
from tronpy.async_tron import PrivateKey, AsyncTron, AsyncHTTPProvider

from src.utils.utils import Utils
from src.utils.types import BodyOptimalFee, BodySendTransaction
from src.utils.types import CoinHelper
from config import Config, decimals


class NodeTRON:
    """TRON NODE"""
    __PROVIDER = AsyncHTTPProvider(Config.NODE_URL)
    NETWORK = "mainnet" if Config.NETWORK == "MAINNET" else "shasta"

    def __new__(cls):
        if not hasattr(cls, 'instance'):
            cls.instance = super(NodeTRON, cls).__new__(cls)
        return cls.instance

    def __init__(self):
        self.node: AsyncTron = AsyncTron(
            provider=self.__PROVIDER if self.NETWORK == "mainnet" else None,
            network=self.NETWORK
        )
        self.public_node: AsyncTron = AsyncTron(
            provider=AsyncHTTPProvider(api_key=Config.HELPER_KEYS) if self.NETWORK == "mainnet" else None,
            network=self.NETWORK
        )

    # <<<=====================================>>> Helper <<<=========================================================>>>

    async def get_energy(self, address: TAddress, energy: int) -> int:
        """If the user has enough energy."""
        account_resources = await self.node.get_account_resource(address)
        __energy = account_resources["EnergyLimit"] if "EnergyLimit" in account_resources else 0
        __energy_used = account_resources["EnergyUsed"] if "EnergyUsed" in account_resources else 0
        total_energy = __energy - __energy_used if __energy > 0 and __energy_used > 0 else 0
        if int(total_energy) <= 0:
            return energy
        elif energy - int(total_energy) <= 0:
            return 0
        else:
            return energy - int(total_energy)

    async def calculate_burn_energy(self, amount: int) -> Union[float, int]:
        """
        Returns the amount of energy generated by burning TRX
        :param amount: Amount of TRX in sun
        :return:
        """
        energy_fee = 0
        parameters = await self.node.get_chain_parameters()
        for parameter in parameters:
            if parameter["key"] == "getEnergyFee":
                energy_fee = parameter["value"]
                break
        if float(energy_fee) == 0:
            return decimals.create_decimal(0)
        fee = (amount / energy_fee) * 1_000_000
        return decimals.create_decimal(fee)

    async def get_account_bandwidth(self, address: TAddress) -> Dict:
        """
        Returns bandwidth data from account.
        :param address: Address of account
        """
        account_resources = await self.node.get_account_resource(address)
        free_bandwidth = account_resources["freeNetLimit"] if "freeNetLimit" in account_resources else 0
        free_bandwidth_used = account_resources["freeNetUsed"] if "freeNetUsed" in account_resources else 0
        total_bandwidth = free_bandwidth - free_bandwidth_used
        return {
            "freeBandwidth": free_bandwidth,
            "freeBandwidthUsed": free_bandwidth_used,
            "totalBandwidth": total_bandwidth
        }

    # <<<=====================================>>> Wallet Methods <<<=================================================>>>

    async def balance(self, address: TAddress, symbol: Optional[str] = None) -> decimal.Decimal:
        """Wallet balance"""
        if symbol is None:
            try:
                balance = await self.node.get_account_balance(addr=address)
            except AddressNotFound:
                balance = 0
        else:
            _, contract_address, dml, __ = CoinHelper.get_token(symbol=symbol.upper())
            contract = await self.node.get_contract(contract_address)
            if int(await contract.functions.balanceOf(address)) > 0:
                balance = int(await contract.functions.balanceOf(address)) / dml
            else:
                balance = 0
        return decimals.create_decimal(balance)

    # <<<=====================================>>> Transaction Methods <<<============================================>>>

    async def optimal_fee(self, body: BodyOptimalFee) -> decimal.Decimal:
        """Optimal fee for transaction"""
        fee = 0
        if body.symbol is None:
            try:
                _ = await self.node.get_account(body.toAddress)
            except AddressNotFound:
                fee += 1.0
            bd = 267
        else:
            _, address, dml, info = CoinHelper.get_token(symbol=body.symbol)
            contract = await self.node.get_contract(address)
            energy = info.get("nb") if int(await contract.functions.balanceOf(body.toAddress)) > 0 else info.get("hb")
            fee = await self.get_energy(address=body.fromAddress, energy=energy) / await self.calculate_burn_energy(1)
            bd = info.get("bd")
        if int((await self.get_account_bandwidth(address=body.fromAddress))["totalBandwidth"]) <= bd:
            fee += 267 / 1_000
        return decimals.create_decimal(fee)

    async def send_transaction(self, body: BodySendTransaction) -> Tuple[bool, Optional[str]]:
        """Send transaction"""
        if body.symbol is None:
            amount = Utils.to_sun(body.amount)
            transaction = self.node.trx.transfer(from_=body.fromAddress, to=body.toAddress, amount=amount)
        else:
            _, address, dml, info = CoinHelper.get_token(symbol=body.symbol)
            contract = await self.node.get_contract(addr=address)
            amount = int(float(body.amount) * dml)
            if int(await contract.functions.balanceOf(body.fromAddress)) * dml < amount:
                raise Exception("You do not have enough funds on your balance to make a transaction!!!")
            transaction = await contract.functions.transfer(body.toAddress, amount)
            transaction = transaction.with_owner(body.fromAddress)
        transaction = await transaction.build()
        transaction = transaction.sign(priv_key=PrivateKey(private_key_bytes=bytes.fromhex(body.fromPrivateKey)))
        await transaction.broadcast()
        return True, transaction.txid


node_tron = NodeTRON()
